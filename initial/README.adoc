---
tags: [spring,spring boot,maven,github]
projects: [initial]
---
////
markDown中的注释
http://sspai.com/25137
http://www.jianshu.com/p/1e402922ee32/
学习中
http://wiselyman.iteye.com/blog/2210250
////
== github技巧

提交快捷键　push ctrl+shift+k

== hot deploy配置 节省调试时间

image::https://raw.githubusercontent.com/tomlxq/gs-spring-boot/master/doc/hot-deploy.png[热布署配置,500,link="https://raw.githubusercontent.com/tomlxq/gs-spring-boot/master/doc/hot-deploy.png"]

> -javaagent:[your_path]\jrebel\jrebel.jar -Xmx512M -Xms512M -XX:MaxPermSize=1024m -noverify

== maven 元素的学习

* groupId定义了项目属于哪个组，这个组往往和项目所在的组织或公司存在关联。譬如在googlecode上建立了一个名为myapp的项目，那么groupId就应该是com.googlecode.myapp
* artifactId定义了当前maven项目在组中唯一的ID，如在前面的groupId为com.googlecode.myapp的例子中，你可能会为不同的子项目(模块)分配artifactId,如:myapp-util,myapp-domain,myapp-web等。
* version指定了项目当前的版本--1.0-SNAPSHOT。SNAPSHOT意为快照，说明该项目还处于开发中，是不稳定的版本。

> maven是一个项目构建工具,利用maven我们不需要手工拷贝包到项目中,只需通过pom.xml文件里的包的描述自动从互联网下载相关依赖包.
若无互联网环境可搭建maven私服(nexus:http://www.sonatype.org/nexus/)
依赖包借助http://mvnrepository.com这个网站来检索

# 手动增加依赖包
[source]
mvn install:install-file -DgroupId=com.oracle "-DartifactId=ojdbc14"
"-Dversion=10.2.0.2.0" "-Dpackaging=jar" "-Dfile=D:\ojdbc14.jar"

此时在pom.xml用如下引入:

[source,xml]
<dependency>
    <groupId>com.oracle</groupId>
    <artifactId>ojdbc14</artifactId>
    <version>10.2.0.2.0</version>
</dependency>


### @RequestMapping

* @RequestMapping是SpringMVC的核心注解,负责访问的url与调用方法之间的映射;
* @RequestMapping可以放在类和方法上;

    *@RequestMapping的属性produces属性控制response返回的形式;*
    *@RequestMapping的属性method属性控制接受访问的类型*

* @ResponseBody(放在方法上或者返回值类型前)将方法参数放置在web body的body中(返回的不是页面而是你所控制的字符)

    *@RequestBody(放在方法参数前)将方法参数放置在web request的body中*

### produces的内容是指定返回的媒体类型让浏览器识别

* 如返回text/plain的话,chrome浏览器下network显示Response的Content-Type:text/plain;
* 如返回application/json的话,chrome浏览器下network显示Response的application/json;

### REST支持的http method(通过@RequestMapping的method属性控制)
* POST:新增
* GET:读取
* PUT/PATCH:更新
* DELETE:删除

添加jackson依赖

jackson-dataformat-xml依赖jackson-bind,这样我们能同时返回xml和json

[source,xml]
<dependency>
    <groupId>com.fasterxml.jackson.dataformat</groupId>
    <artifactId>jackson-dataformat-xml</artifactId>
    <version>2.5.3</version>
</dependency>

若只需返回json数据(大多数项目都是这样),将上面依赖更换为
[source,xml]
 <dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.5.3</version>
</dependency>

### 服务器端推送

* SSE(server send event)是一种服务器端向浏览器推送消息的技术,而不是我们常规的浏览器像server请求然后响应;

> 当我们需要使用server向浏览器主动推送数据的时候,请考虑使用该项技术,而不是考虑具有双向通讯功能的websocket;
以前我们用ajax轮询server也能实现,服务器负担大;

* sse原理是向server请求一次后,server会挂住请求不放(此时浏览器里请求状态是pending),等有数据后才返回给浏览器,然后再发起下一次请求,以此类推;

> 所有主流浏览器均支持服务器发送事件，除了 Internet Explorer(6,7,8,9);

### 文件上传

* 在控制器参数使用@RequestParam("file") MultipartFile file接受单个文件上传;
* 在控制器参数使用@RequestParam("file") MultipartFile[] files接受多个文件上传;

> 通过配置MultipartResolver来配置文件上传的一些属性;
[source,java]
@Bean
public MultipartResolver multipartResolver() {
    CommonsMultipartResolver multipartResolver = new CommonsMultipartResolver();
    multipartResolver.setMaxUploadSize(1000000);//最大上传100Ｍ
    return multipartResolver;
}

////
spring视图 ContentNegotiatingViewResolver
http://wiselyman.iteye.com/blog/2214965
////
### ContentNegotiatingViewResolver支持在Spring MVC下输出不同的格式;

ContentNegotiatingViewResolver是ViewResolver的一个实现;

ContentNegotiatingViewResolver使用request的媒体类型,根据扩展名选择不同的view输出不同的格式;

ContentNegotiatingViewResolver不是自己处理view,而是代理给不同的ViewResolver来处理不同的view;

* jsp

> view:WEB-INF/views/demoObj.jsp
> viewResolver:UrlBasedViewResolver或InternalResourceViewResolver

* pdf

> view:PdfView
> viewResolver:PdfViewResolver

* json

> view:MappingJackson2JsonView
> viewResolver:JsonViewResolver

* xml

> view:MarshallingView
> viewResolver:XmlViewResolver

* xls

> view:XlsView
> viewResolver:XlsViewResolver

[source,xml]
----
<!--xml-->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-oxm</artifactId>
</dependency>
<!--pdf-->
<dependency>
    <groupId>com.lowagie</groupId>
    <artifactId>itext</artifactId>
    <version>4.2.1</version>
</dependency>
<!-- xls-->
<dependency>
    <groupId>org.apache.poi</groupId>
    <artifactId>poi</artifactId>
    <version>3.10-beta2</version>
</dependency>
----

### 配置路径匹配参数

在spring MVC中路径参数如果带.的话,.后面的值将被忽略,本例演示配置configurePathMatch不忽略点后面的参数

[source,java]
----
//http://localhost:8080/configPath/tomLuo.home
//request value:tomLuo
@RequestMapping("/configPath/{test}")
public @ResponseBody
String configPath(@PathVariable String test){
    return "request value:"+test;
}
----

在继承WebMvcConfigurerAdapter的DemoMVCConfig类中重载configurePathMatch

[source,java]
----
//如果设置成configurer.setUseSuffixPatternMatch(false); request value:tomLuo.home
//contentNegotiatingViewResolver不能工作
@Override
public void configurePathMatch(PathMatchConfigurer configurer) {
    configurer.setUseSuffixPatternMatch(false);
}
----

### 快捷定义ViewController

我们经常涉及到页面转向,但没任何处理业务的时候,快捷的页面转向定义会节省好多代码;
常规的方案是这样写的

[source,java]
----
@RequestMapping(value = {"/", ""})
public ModelAndView index() {
    return new ModelAndView("index");
}
----

在继承WebMvcConfigurerAdapter的DemoMVCConfig类中重载addViewControllers
[source,java]
----
@Override
public void addViewControllers(ViewControllerRegistry registry) {
    registry.addViewController("/").setViewName("/index");
    //添加更多
}
----

hot-deployee.png